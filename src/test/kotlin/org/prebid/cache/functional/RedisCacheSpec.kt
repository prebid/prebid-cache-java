package org.prebid.cache.functional

import io.kotest.assertions.assertSoftly
import io.kotest.assertions.throwables.shouldNotThrowAny
import io.kotest.assertions.throwables.shouldThrowExactly
import io.kotest.core.spec.style.ShouldSpec
import io.kotest.matchers.collections.shouldContain
import io.kotest.matchers.shouldBe
import io.kotest.matchers.string.shouldContain
import org.prebid.cache.functional.BaseSpec.Companion.prebidCacheConfig
import org.prebid.cache.functional.model.request.PayloadTransfer
import org.prebid.cache.functional.model.request.RequestObject
import org.prebid.cache.functional.model.response.ResponseObject
import org.prebid.cache.functional.service.ApiException
import org.prebid.cache.functional.testcontainers.ContainerDependencies
import org.prebid.cache.functional.util.getRandomUuid
import org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR
import org.springframework.http.HttpStatus.NOT_FOUND
import java.util.*

class RedisCacheSpec : ShouldSpec({

    should("throw an exception when cache record is absent in Redis repository") {
        // given: Prebid cache config
        val config = prebidCacheConfig.getBaseRedisConfig("true")
        val cachePrefix = config["cache.prefix"]

        // when: GET cache endpoint with random UUID is called
        val randomUuid = getRandomUuid()
        val exception = shouldThrowExactly<ApiException> { BaseSpec.getPrebidCacheApi(config).getCache(randomUuid) }

        // then: Not Found exception is thrown
        assertSoftly {
            exception.statusCode shouldBe NOT_FOUND.value()
            exception.responseBody shouldContain "\"message\":\"Resource Not Found: uuid $cachePrefix$randomUuid\""
        }
    }

    should("rethrow an exception from Redis cache server when such happens") {
        // given: Prebid Cache with set min and max expiry as 0
        val config = prebidCacheConfig.getBaseRedisConfig("false") + prebidCacheConfig.getCacheExpiryConfig("0", "0")
        val prebidCacheApi = BaseSpec.getPrebidCacheApi(config)

        // and: Request object
        val requestObject = RequestObject.getDefaultJsonRequestObject()

        // when: POST cache endpoint is called
        val exception = shouldThrowExactly<ApiException> { prebidCacheApi.postCache(requestObject) }

        // then: Internal Server Error exception is thrown
        assertSoftly {
            exception.statusCode shouldBe INTERNAL_SERVER_ERROR.value()
            exception.responseBody shouldContain "\"message\":\"ERR invalid expire time in setex\""
        }

        // cleanup
        ContainerDependencies.prebidCacheContainerPool.stopPrebidCacheContainer(config)
    }

    should("return back PBC UUID when allow_external_UUID=false and request object was successfully cached in Redis") {
        // given: Request object
        val requestObject = RequestObject.getDefaultJsonRequestObject()

        // when: POST cache endpoint is called
        val responseObject: ResponseObject = BaseSpec.getPrebidCacheApi().postCache(requestObject)

        // then: Response contains 1 UUID generated by Prebid Cache
        responseObject.responses.isEmpty() shouldBe false
        responseObject.responses.size shouldBe 1
        shouldNotThrowAny { UUID.fromString(responseObject.responses[0].uuid) }
    }

    should("return back two random UUIDs when allow_external_UUID=false and 2 payload transfers were successfully cached") {
        // given: Request object
        val xmlPayloadTransfer = PayloadTransfer.getDefaultXmlPayloadTransfer().apply { key = null }
        val jsonPayloadTransfer = PayloadTransfer.getDefaultJsonPayloadTransfer().apply { key = null }
        val requestObject = RequestObject.of(xmlPayloadTransfer, jsonPayloadTransfer)

        // when: POST cache endpoint is called
        val responseObject: ResponseObject = BaseSpec.getPrebidCacheApi().postCache(requestObject)

        // then: Response contains 2 UUIDs generated by Prebid Cache
        responseObject.responses.isEmpty() shouldBe false
        responseObject.responses.size shouldBe 2
        shouldNotThrowAny { UUID.fromString(responseObject.responses[0].uuid) }
        shouldNotThrowAny { UUID.fromString(responseObject.responses[1].uuid) }
    }

    should("return back a request UUID when allow_external_UUID=true and request object was successfully cached") {
        // given: Prebid Cache with enabled allow_external_UUID property
        val prebidCacheApi = BaseSpec.getPrebidCacheApi(prebidCacheConfig.getBaseRedisConfig("true"))

        // and: Request object with set payload transfer UUID key
        val requestObject = RequestObject.getDefaultJsonRequestObject().apply { puts[0].key = getRandomUuid() }

        // when: POST cache endpoint is called
        val responseObject: ResponseObject = prebidCacheApi.postCache(requestObject)

        // then: UUID from request is returned
        responseObject.responses.isEmpty() shouldBe false
        responseObject.responses.size shouldBe 1
        responseObject.responses[0].uuid shouldBe requestObject.puts[0].key
    }

    should("return back two request UUIDs when allow_external_UUID=true and 2 payload transfers were successfully cached in Redis") {
        // given: Prebid Cache with enabled allow_external_UUID property
        val prebidCacheApi = BaseSpec.getPrebidCacheApi(prebidCacheConfig.getBaseRedisConfig("true"))

        // and: Request object with set 2 payload transfers
        val xmlPayloadTransfer = PayloadTransfer.getDefaultXmlPayloadTransfer().apply { key = getRandomUuid() }
        val jsonPayloadTransfer = PayloadTransfer.getDefaultJsonPayloadTransfer().apply { key = getRandomUuid() }
        val requestObject = RequestObject.of(xmlPayloadTransfer, jsonPayloadTransfer)

        // when: POST cache endpoint is called
        val responseObject: ResponseObject = prebidCacheApi.postCache(requestObject)

        // then: UUIDs from request are returned
        responseObject.responses.isEmpty() shouldBe false
        responseObject.responses.size shouldBe 2

        val responseUuidList = listOf(responseObject.responses[0].uuid, responseObject.responses[1].uuid)
        responseUuidList shouldContain requestObject.puts[0].key
        responseUuidList shouldContain requestObject.puts[1].key
    }
})
